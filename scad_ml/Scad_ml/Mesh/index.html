<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Mesh (scad_ml.Scad_ml.Mesh)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 2.1.1"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body class="odoc"><nav class="odoc-nav"><a href="../index.html">Up</a> â€“ <a href="../../index.html">scad_ml</a> &#x00BB; <a href="../index.html">Scad_ml</a> &#x00BB; Mesh</nav><header class="odoc-preamble"><h1>Module <code><span>Scad_ml.Mesh</span></code></h1><p>Generation, and manipulation of 3-dimensional meshes (points and faces) that can be mapped into <a href="../Scad/index.html#type-d3"><code>Scad.d3</code></a> as polyhedrons.</p><p>This data type (and its constructors / transformers) is largely a port of the <a href="https://github.com/revarbat/BOSL2/blob/master/vnf.scad">vnf structure module</a> of the <a href="https://github.com/revarbat/BOSL2/">BOSL2 OpenSCAD library</a>.</p></header><nav class="odoc-toc"><ul><li><a href="#sweeps-and-extrusions-with-roundovers">Sweeps and Extrusions with roundovers</a></li><li><a href="#function-plotting">Function Plotting</a></li><li><a href="#mesh-utilities">Mesh Utilities</a></li><li><a href="#basic-transfomations">Basic Transfomations</a></li><li><a href="#debugging-helpers">Debugging helpers</a></li><li><a href="#output">Output</a></li></ul></nav><div class="odoc-content"><div class="odoc-spec"><div class="spec type" id="type-t" class="anchored"><a href="#type-t" class="anchor"></a><code><span><span class="keyword">type</span> t</span><span> = <span class="keyword">private</span> </span><span>{</span></code><table><tr id="type-t.n_points" class="anchored"><td class="def record field"><a href="#type-t.n_points" class="anchor"></a><code><span>n_points : int;</span></code></td></tr><tr id="type-t.points" class="anchored"><td class="def record field"><a href="#type-t.points" class="anchor"></a><code><span>points : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> list</span>;</span></code></td></tr><tr id="type-t.faces" class="anchored"><td class="def record field"><a href="#type-t.faces" class="anchor"></a><code><span>faces : <span><span>int list</span> list</span>;</span></code></td></tr></table><code><span>}</span></code></div><div class="spec-doc"><p>Points and faces 3-dimensional mesh.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-endcaps" class="anchored"><a href="#type-endcaps" class="anchor"></a><code><span><span class="keyword">type</span> endcaps</span><span> = </span><span>[ </span></code><table><tr id="type-endcaps.Loop" class="anchored"><td class="def constructor"><a href="#type-endcaps.Loop" class="anchor"></a><code><span>| </span></code><code><span>`Loop</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>last/top row wrapped to the first/bottom</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.Both" class="anchored"><td class="def constructor"><a href="#type-endcaps.Both" class="anchor"></a><code><span>| </span></code><code><span>`Both</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>both bottom and top rows are closed with flat faces</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.None" class="anchored"><td class="def constructor"><a href="#type-endcaps.None" class="anchor"></a><code><span>| </span></code><code><span>`None</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>neither top or bottom rows are closed with a face</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.Top" class="anchored"><td class="def constructor"><a href="#type-endcaps.Top" class="anchor"></a><code><span>| </span></code><code><span>`Top</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>a face is generated to close the top row with itself</p><span class="comment-delim">*)</span></td></tr><tr id="type-endcaps.Bot" class="anchored"><td class="def constructor"><a href="#type-endcaps.Bot" class="anchor"></a><code><span>| </span></code><code><span>`Bot</span></code></td><td class="def-doc"><span class="comment-delim">(*</span><p>a face is generated to close the bottom row with itself</p><span class="comment-delim">*)</span></td></tr></table><code><span> ]</span></code></div><div class="spec-doc"><p>Describes desired row wrapping behaviour in <a href="#val-of_rows"><code>of_rows</code></a>, which creates a mesh from rows of points.</p></div></div><div class="odoc-spec"><div class="spec type" id="type-style" class="anchored"><a href="#type-style" class="anchor"></a><code><span><span class="keyword">type</span> style</span><span> = </span><span>[ </span></code><table><tr id="type-style.Default" class="anchored"><td class="def constructor"><a href="#type-style.Default" class="anchor"></a><code><span>| </span></code><code><span>`Default</span></code></td></tr><tr id="type-style.Alt" class="anchored"><td class="def constructor"><a href="#type-style.Alt" class="anchor"></a><code><span>| </span></code><code><span>`Alt</span></code></td></tr><tr id="type-style.MinEdge" class="anchored"><td class="def constructor"><a href="#type-style.MinEdge" class="anchor"></a><code><span>| </span></code><code><span>`MinEdge</span></code></td></tr><tr id="type-style.Quincunx" class="anchored"><td class="def constructor"><a href="#type-style.Quincunx" class="anchor"></a><code><span>| </span></code><code><span>`Quincunx</span></code></td></tr><tr id="type-style.Convex" class="anchored"><td class="def constructor"><a href="#type-style.Convex" class="anchor"></a><code><span>| </span></code><code><span>`Convex</span></code></td></tr><tr id="type-style.Concave" class="anchored"><td class="def constructor"><a href="#type-style.Concave" class="anchor"></a><code><span>| </span></code><code><span>`Concave</span></code></td></tr></table><code><span> ]</span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-empty" class="anchored"><a href="#val-empty" class="anchor"></a><code><span><span class="keyword">val</span> empty : <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>empty</code></p><p>An empty <code>t</code>, with no points.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-make" class="anchored"><a href="#val-make" class="anchor"></a><code><span><span class="keyword">val</span> make : <span>points:<span><a href="../Vec3/index.html#type-t">Vec3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <span>faces:<span><span>int list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>make ~points ~faces</code></p><p>Create a mesh <code>t</code> from a list of <a href="../Vec3/index.html#type-t"><code>Vec3.t</code></a> <code>points</code>, and a list of <code>faces</code> described by indices into <code>points</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_rows" class="anchored"><a href="#val-of_rows" class="anchor"></a><code><span><span class="keyword">val</span> of_rows : 
  <span>?rev:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?endcaps:<a href="#type-endcaps">endcaps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?col_wrap:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?style:<a href="#type-style">style</a> <span class="arrow">&#45;&gt;</span></span>
  <span><span><span><a href="../Vec3/index.html#type-t">Vec3.t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_rows ?rev ?endcaps ?col_wrap ?style rows</code></p><p>Create a <a href="#type-t"><code>t</code></a> representing a polyhedron from a list of layers (counter_clockwise loops of 3d points). <code>endcaps</code> defaults to <code>`Both</code>, which specifies that faces should be generated to close off the bottom and top layers of the generated shape. If it is instead set to <code>`Loop</code>, the open faces of the first and last layers will be closed with one another. For more advanced usages, one or both of the endcaps can be left open, so the resulting meshes can be closed off by some other means.</p><ul><li><code>col_wrap</code> sets whether faces should be generated to loop between the ends of each row.</li><li>If <code>rev</code> is <code>true</code>, faces winding direction will be reversed (default = <code>false</code>)</li><li><p><code>style</code> governs how the quadrilaterals formed by the rows and columns of points are divided into triangles:</p><ul><li><code>`Default</code> is an arbitrary systematic subdivision in the same direction</li><li><code>`Alt</code> is the uniform subdivision in the other (alternate direction)</li><li><code>`MinEdge</code> picks the shorter edge to subdivide the quadrilateral, so the division may not be uniform across the shape</li><li><code>`Quincunx</code> adds a vertex in the middle of each quadrilateral and creates four triangles</li><li><code>`Convex</code> and <code>`Concave</code> choose the locally convex/concave subdivision</li></ul></li><li>If <code>rows</code> is empty, a <a href="#val-empty"><code>empty</code></a> is returned. Throws <code>Invalid_argument</code> if <code>rows</code> contains only one row, or if it is not rectangular (any row differs in length).</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-of_ragged" class="anchored"><a href="#val-of_ragged" class="anchor"></a><code><span><span class="keyword">val</span> of_ragged : <span>?looped:bool <span class="arrow">&#45;&gt;</span></span> <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><span><span><a href="../Vec3/index.html#type-t">Vec3.t</a> list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_ragged ?looped ?reverse rows</code></p><p>Create a triangular mesh from a list of rows, where each row can differ in length relative to its neighbours by up to 2. Since the rows can be ragged, no (columnar) wrapping is done, thus they are best described as rows, rather than layers as with <a href="#val-of_rows"><code>of_rows</code></a> which produces an enclosed polyhedron. Instead, this function is useful for the generation of triangular patches that can be joined with one another to create a complete polyhedron. Setting <code>looped</code> to true will generate faces between the last and first rows, so long as their lengths differ by no more than 2. Face winding order is reversed if <code>reverse</code> is <code>true</code>. Throws <code>Invalid_argument</code> if a row length delta of greater than 2 is encountered.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_path2" class="anchored"><a href="#val-of_path2" class="anchor"></a><code><span><span class="keyword">val</span> of_path2 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Path2/index.html#type-t">Path2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path3 ?rev layer</code></p><p>Create a mesh from a single path (a closed loop of <a href="../Vec2/index.html#type-t"><code>Vec2.t</code></a>), returning a <a href="#type-t"><code>t</code></a> with a single face including all of the points. Face winding order is reversed if <code>rev</code> is <code>true</code>. This can be useful for producing a flat patch mesh to be combined with other meshes to produce a complete shape.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_path3" class="anchored"><a href="#val-of_path3" class="anchor"></a><code><span><span class="keyword">val</span> of_path3 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_path3 ?rev layer</code></p><p>Create a mesh from a single path (a closed loop of <a href="../Vec3/index.html#type-t"><code>Vec3.t</code></a>, should be coplanar though it is not confirmed), returning a <a href="#type-t"><code>t</code></a> with a single face including all of the points. Face winding order is reversed if <code>rev</code> is <code>true</code>. This can be useful for producing a flat patch mesh to be combined with other meshes to produce a complete shape.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_poly2" class="anchored"><a href="#val-of_poly2" class="anchor"></a><code><span><span class="keyword">val</span> of_poly2 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_poly2 ?rev poly</code></p><p>Create a mesh from a 2d polygon. If <code>poly</code> does not have any holes, then this is equivalent to <a href="#val-of_path2"><code>Mesh.of_path2</code></a>. If there are holes, polyhole partitioning is performed to determine a set of faces that can close the points.</p><p>The earcutting algorithm used to partition the polygon into faces is a port of RonaldoCMP's work found <a href="https://github.com/RonaldoCMP/Polygon-stuffs/blob/master/polyHolePartition.scad">here</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_poly3" class="anchored"><a href="#val-of_poly3" class="anchor"></a><code><span><span class="keyword">val</span> of_poly3 : <span>?rev:bool <span class="arrow">&#45;&gt;</span></span> <span><a href="../Poly3/index.html#type-t">Poly3.t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_poly3 ?rev poly</code></p><p>Create a mesh from a 3d polygon. If <code>poly</code> does not have any holes, then this is equivalent to <a href="#val-of_path3"><code>Mesh.of_path3</code></a>. If there are holes, polyhole partitioning is performed to determine a set of faces that can close the points.</p><p>The earcutting algorithm used to partition the polygon into faces is a port of RonaldoCMP's work found <a href="https://github.com/RonaldoCMP/Polygon-stuffs/blob/master/polyHolePartition.scad">here</a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-of_polygons" class="anchored"><a href="#val-of_polygons" class="anchor"></a><code><span><span class="keyword">val</span> of_polygons : <span><span><a href="../Path3/index.html#type-t">Path3.t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>of_polygons polys</code></p><p>Create a polyhedron mesh from a list of polygonal point faces.</p></div></div><h2 id="sweeps-and-extrusions-with-roundovers"><a href="#sweeps-and-extrusions-with-roundovers" class="anchor"></a>Sweeps and Extrusions with roundovers</h2><p>Extrusions from 2d to 3d with optional roundovers based on the implementations found in the <a href="https://github.com/revarbat/BOSL2">BOSL2</a> library's <code>offset_sweep</code> functions from the <a href="https://github.com/revarbat/BOSL2/blob/master/rounding.scad">rounding</a> module.</p><div class="odoc-spec"><div class="spec module" id="module-Cap" class="anchored"><a href="#module-Cap" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Cap/index.html">Cap</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Configuration module for declaring how extrusions from 2d to 3d via <a href="#val-sweep"><code>Mesh.sweep</code></a> should be capped off.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-sweep" class="anchored"><a href="#val-sweep" class="anchor"></a><code><span><span class="keyword">val</span> sweep : 
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?spec:<a href="Cap/index.html#type-t">Cap.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>transforms:<span><a href="../MultMatrix/index.html#type-t">MultMatrix.t</a> list</span> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>sweep ?check_valid ?winding ?merge ?fn ?fs ?fa ?spec ~transforms poly</code></p><p>Sweep a 2d polygon into a 3d mesh by applying a sequence of <code>transforms</code> to the original shape. The <code>winding</code> parameter can be used to set automatic enforcement of polygon winding direction, which will impact the winding of the generated faces of the mesh. What is done with the endcaps can be specified with <code>spec</code>. By default the ends of the extrusion are sealed with flat faces, but they can instead be looped to eachother, left empty, or rounded over. If <code>merge</code> is <code>true</code> (as is default), <a href="#val-merge_points"><code>merge_points</code></a> is applied to the resulting mesh, as duplicate points are introduced when end caps are joined to the outer and inner meshes. If the duplicate points aren't a problem for you (they aren't <i>necessarily</i>), this can be turned off to save some compute.</p><p>Relevant when roundovers are on:</p><ul><li><code>check_valid</code> determines whether validity checks are performed during offset operations, see <a href="../Path2/index.html#val-offset"><code>Path2.offset</code></a>, for cap roundovers (if specified).</li><li><code>fn</code>, <code>fs</code>, and <code>fa</code> determine number of points used when generating new points in the <a href="../Path2/index.html#val-offset"><code>Path2.offset</code></a> roundover, if <code>`Radius</code> mode is being used.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-linear_extrude" class="anchored"><a href="#val-linear_extrude" class="anchor"></a><code><span><span class="keyword">val</span> linear_extrude : 
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?slices:int <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_k:float <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_k:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../Vec2/index.html#type-t">Vec2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?center:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>height:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>linear_extrude ?check_valid ?merge ?winding ?fa ?slices ?scale_k ?twist_k ?scale ?twist
    ?center ?caps ~height poly</code></p><p>Vertically extrude a 2d polygon into a 3d mesh. <code>slices</code>, <code>scale</code>, <code>twist</code>, <code>center</code>, and <code>height</code> parameters are analogous to those found on <a href="../Scad/index.html#val-linear_extrude"><code>Scad.linear_extrude</code></a>. See <a href="#val-sweep"><code>sweep</code></a> for explaination of shared parameters (note: <code>caps</code> is a subset of <code>spec</code>, since the ends of a linear extrusion cannot be looped)</p></div></div><div class="odoc-spec"><div class="spec value" id="val-path_extrude" class="anchored"><a href="#val-path_extrude" class="anchor"></a><code><span><span class="keyword">val</span> path_extrude : 
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?winding:<span>[&lt; `CCW <span>| `CW</span> <span>| `NoCheck</span> CCW CW ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?spec:<a href="Cap/index.html#type-t">Cap.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?euler:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_k:float <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_k:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../Vec2/index.html#type-t">Vec2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>path:<a href="../Path3/index.html#type-t">Path3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>path_extrude ?check_valid ?merge ?winding ?spec ?euler
     ?scale_k ?twist_k ?scale ?twist ~path poly</code></p><p>Extrude a 2d polygon along the given <code>path</code> into a 3d mesh. This is a convenience function that composes transform generation using <a href="../Path3/index.html#val-to_transforms"><code>Path3.to_transforms</code></a> with <a href="#val-sweep"><code>Mesh.sweep</code></a>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-helix_extrude" class="anchored"><a href="#val-helix_extrude" class="anchor"></a><code><span><span class="keyword">val</span> helix_extrude : 
  <span>?check_valid:<span>[ <span>`Quality of int</span> <span>| `No</span> ]</span> <span class="arrow">&#45;&gt;</span></span>
  <span>?merge:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?fa:float <span class="arrow">&#45;&gt;</span></span>
  <span>?fs:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale_k:float <span class="arrow">&#45;&gt;</span></span>
  <span>?twist_k:float <span class="arrow">&#45;&gt;</span></span>
  <span>?scale:<a href="../Vec2/index.html#type-t">Vec2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?twist:float <span class="arrow">&#45;&gt;</span></span>
  <span>?caps:<a href="Cap/index.html#type-caps">Cap.caps</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?left:bool <span class="arrow">&#45;&gt;</span></span>
  <span>n_turns:int <span class="arrow">&#45;&gt;</span></span>
  <span>pitch:float <span class="arrow">&#45;&gt;</span></span>
  <span>?r2:float <span class="arrow">&#45;&gt;</span></span>
  <span>float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>helix_extrude ?check_valid ?merge ?fn ?fs ?fa ?scale_k ?twist_k ?scale ?twist
     ?caps ?left ~n_turns ~pitch ?r2 r1 poly</code></p><p>Helical extrusion of a 2d polygon into a 3d mesh. This is a special case of <a href="#val-path_extrude"><code>Mesh.path_extrude</code></a>, but following a path generated with <a href="../Path3/index.html#val-helix"><code>Path3.helix</code></a>, and using transforms that take the helical rotation into account.</p></div></div><div class="odoc-spec"><div class="spec module" id="module-Prism" class="anchored"><a href="#module-Prism" class="anchor"></a><code><span><span class="keyword">module</span> <a href="Prism/index.html">Prism</a></span><span> : <span class="keyword">sig</span> ... <span class="keyword">end</span></span></code></div><div class="spec-doc"><p>Rounded prism configuration module.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-prism" class="anchored"><a href="#val-prism" class="anchor"></a><code><span><span class="keyword">val</span> prism : 
  <span>?debug:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?holes:<a href="Prism/index.html#type-holes">Prism.holes</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer:<a href="Prism/index.html#type-spec">Prism.spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly3/index.html#type-t">Poly3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly3/index.html#type-t">Poly3.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Scad_ml__Mesh0.t</span></span></code></div><div class="spec-doc"><p><code>prism ?debug ?fn ?holes ?outer bottom top</code></p><p>Create a prism with continuous curvature rounding from the given <code>bottom</code> and <code>top</code> polygons. The edges running between the corresponding paths must produce a valid polyhedron with coplanar side faces, thus the top should generally be the same shape as the bottom translated/transformed in such a way as to not violate this assumption (avoid z-rotation for one). Roundover specifications are provided with <code>outer</code> and <code>holes</code> (see <a href="Prism/index.html#type-spec"><code>Prism.spec</code></a> and <a href="Prism/index.html#type-holes"><code>Prism.holes</code></a> for details).</p><ul><li><code>debug</code> can be set to <code>true</code> to skip validity checks that would otherwise raise exceptions on failure, so a mesh can still be obtained for inspection.</li></ul></div></div><div class="odoc-spec"><div class="spec value" id="val-linear_prism" class="anchored"><a href="#val-linear_prism" class="anchor"></a><code><span><span class="keyword">val</span> linear_prism : 
  <span>?debug:bool <span class="arrow">&#45;&gt;</span></span>
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>?holes:<a href="Prism/index.html#type-holes">Prism.holes</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?outer:<a href="Prism/index.html#type-spec">Prism.spec</a> <span class="arrow">&#45;&gt;</span></span>
  <span>?center:bool <span class="arrow">&#45;&gt;</span></span>
  <span>height:float <span class="arrow">&#45;&gt;</span></span>
  <span><a href="../Poly2/index.html#type-t">Poly2.t</a> <span class="arrow">&#45;&gt;</span></span>
  <span class="xref-unresolved">Scad_ml__Mesh0.t</span></span></code></div><div class="spec-doc"><p><code>linear_prism ?debug ?fn ?holes ?outer ?center ~height bottom</code></p><p>Create a prism with continuous curvature rounding by extruding the polygon <code>bottom</code> lineraly upward to the given <code>height</code>. If <code>center</code> is <code>true</code>, the resulting prism will be centred in z around the xy plane. See the more general case <a href="#val-prism"><code>prism</code></a> for more details.</p></div></div><h2 id="function-plotting"><a href="#function-plotting" class="anchor"></a>Function Plotting</h2><p>Ported from the <a href="https://github.com/rcolyer/plot-function">PlotFunction</a> library by Ryan Colyer.</p><div class="odoc-spec"><div class="spec value" id="val-cartesian_plot" class="anchored"><a href="#val-cartesian_plot" class="anchor"></a><code><span><span class="keyword">val</span> cartesian_plot : 
  <span>min_x:float <span class="arrow">&#45;&gt;</span></span>
  <span>x_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>max_x:float <span class="arrow">&#45;&gt;</span></span>
  <span>min_y:float <span class="arrow">&#45;&gt;</span></span>
  <span>y_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>max_y:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>x:float <span class="arrow">&#45;&gt;</span></span> <span>y:float <span class="arrow">&#45;&gt;</span></span> float )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>cartesian_plot ~min_x ~x_steps ~max_x ~min_y ~y_steps ~max_y f</code></p><p>Create a mesh of the function <code>f</code> (from x and y to z) over the ranges of x and y defined by the rest of the parameters.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-polar_plot" class="anchored"><a href="#val-polar_plot" class="anchor"></a><code><span><span class="keyword">val</span> polar_plot : 
  <span>?r_step:float <span class="arrow">&#45;&gt;</span></span>
  <span>max_r:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>r:float <span class="arrow">&#45;&gt;</span></span> <span>a:float <span class="arrow">&#45;&gt;</span></span> float )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>polar_plot ?r_step ~max_r f</code></p><p>Create a mesh of the function <code>f</code> (from radius and angle to z) between the z-axis and the radius <code>max_r</code>, with the minimum radial step <code>r_step</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-axial_plot" class="anchored"><a href="#val-axial_plot" class="anchor"></a><code><span><span class="keyword">val</span> axial_plot : 
  <span>?fn:int <span class="arrow">&#45;&gt;</span></span>
  <span>min_z:float <span class="arrow">&#45;&gt;</span></span>
  <span>z_steps:int <span class="arrow">&#45;&gt;</span></span>
  <span>max_z:float <span class="arrow">&#45;&gt;</span></span>
  <span><span>( <span>z:float <span class="arrow">&#45;&gt;</span></span> <span>a:float <span class="arrow">&#45;&gt;</span></span> float )</span> <span class="arrow">&#45;&gt;</span></span>
  <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>axial_plot ?fn ~min_z ~z_step ~max_z f</code></p><p>Create a mesh of the function <code>f</code> (from z-height and angle to radius). <code>fn</code> sets the number of angular steps around the z-axis.</p></div></div><h2 id="mesh-utilities"><a href="#mesh-utilities" class="anchor"></a>Mesh Utilities</h2><div class="odoc-spec"><div class="spec value" id="val-join" class="anchored"><a href="#val-join" class="anchor"></a><code><span><span class="keyword">val</span> join : <span><span><a href="#type-t">t</a> list</span> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>join ts</code></p><p>Join a list of meshes. This is not a boolean operation, it is simply collecting the points from each and updating face indices accordingly. Intended for use when building a closed mesh from a set of partial meshes.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-merge_points" class="anchored"><a href="#val-merge_points" class="anchor"></a><code><span><span class="keyword">val</span> merge_points : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>merge_points ?eps t</code></p><p>Eliminate duplicate points (less than <code>eps</code> distance apart) from <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_face" class="anchored"><a href="#val-add_face" class="anchor"></a><code><span><span class="keyword">val</span> add_face : <span><span>int list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_face face t</code></p><p>Add a single face to the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-add_faces" class="anchored"><a href="#val-add_faces" class="anchor"></a><code><span><span class="keyword">val</span> add_faces : <span><span><span>int list</span> list</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>add_faces faces t</code></p><p>Add a list of faces to the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-rev_faces" class="anchored"><a href="#val-rev_faces" class="anchor"></a><code><span><span class="keyword">val</span> rev_faces : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div><div class="spec-doc"><p><code>rev_faces t</code></p><p>Flip all faces of the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-volume" class="anchored"><a href="#val-volume" class="anchor"></a><code><span><span class="keyword">val</span> volume : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>volume t</code></p><p>Calculate the volume of the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-area" class="anchored"><a href="#val-area" class="anchor"></a><code><span><span class="keyword">val</span> area : <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> float</span></code></div><div class="spec-doc"><p><code>area t</code></p><p>Calculate the surface area of the mesh <code>t</code>.</p></div></div><div class="odoc-spec"><div class="spec value" id="val-centroid" class="anchored"><a href="#val-centroid" class="anchor"></a><code><span><span class="keyword">val</span> centroid : <span>?eps:float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Vec3/index.html#type-t">Vec3.t</a></span></code></div><div class="spec-doc"><p><code>centroid ?eps t</code></p><p>Calculate the centroid of the mesh <code>t</code>.</p></div></div><h2 id="basic-transfomations"><a href="#basic-transfomations" class="anchor"></a>Basic Transfomations</h2><div class="odoc-spec"><div class="spec value" id="val-translate" class="anchored"><a href="#val-translate" class="anchor"></a><code><span><span class="keyword">val</span> translate : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rotate" class="anchored"><a href="#val-rotate" class="anchor"></a><code><span><span class="keyword">val</span> rotate : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-rotate_about_pt" class="anchored"><a href="#val-rotate_about_pt" class="anchor"></a><code><span><span class="keyword">val</span> rotate_about_pt : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-quaternion" class="anchored"><a href="#val-quaternion" class="anchor"></a><code><span><span class="keyword">val</span> quaternion : <span><a href="../Quaternion/index.html#type-t">Quaternion.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-quaternion_about_pt" class="anchored"><a href="#val-quaternion_about_pt" class="anchor"></a><code><span><span class="keyword">val</span> quaternion_about_pt : <span><a href="../Quaternion/index.html#type-t">Quaternion.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-vector_rotate" class="anchored"><a href="#val-vector_rotate" class="anchor"></a><code><span><span class="keyword">val</span> vector_rotate : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-vector_rotate_about_pt" class="anchored"><a href="#val-vector_rotate_about_pt" class="anchor"></a><code><span><span class="keyword">val</span> vector_rotate_about_pt : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span>float <span class="arrow">&#45;&gt;</span></span> <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-multmatrix" class="anchored"><a href="#val-multmatrix" class="anchor"></a><code><span><span class="keyword">val</span> multmatrix : <span><a href="../MultMatrix/index.html#type-t">MultMatrix.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-scale" class="anchored"><a href="#val-scale" class="anchor"></a><code><span><span class="keyword">val</span> scale : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><div class="odoc-spec"><div class="spec value" id="val-mirror" class="anchored"><a href="#val-mirror" class="anchor"></a><code><span><span class="keyword">val</span> mirror : <span><a href="../Vec3/index.html#type-t">Vec3.t</a> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="#type-t">t</a></span></code></div></div><h2 id="debugging-helpers"><a href="#debugging-helpers" class="anchor"></a>Debugging helpers</h2><div class="odoc-spec"><div class="spec value" id="val-show_points" class="anchored"><a href="#val-show_points" class="anchor"></a><code><span><span class="keyword">val</span> show_points : <span><span>( <span>int <span class="arrow">&#45;&gt;</span></span> <a href="../Scad/index.html#type-d3">Scad.d3</a> )</span> <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Scad/index.html#type-d3">Scad.d3</a></span></code></div></div><h2 id="output"><a href="#output" class="anchor"></a>Output</h2><div class="odoc-spec"><div class="spec value" id="val-to_scad" class="anchored"><a href="#val-to_scad" class="anchor"></a><code><span><span class="keyword">val</span> to_scad : <span>?convexity:int <span class="arrow">&#45;&gt;</span></span> <span><a href="#type-t">t</a> <span class="arrow">&#45;&gt;</span></span> <a href="../Scad/index.html#type-d3">Scad.d3</a></span></code></div></div></div></body></html>